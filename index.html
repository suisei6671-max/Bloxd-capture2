<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>3面テクスチャ → 3Dブロック画像</title>
  <style>
    body {
      background: #1a1f2e;
      color: white;
      font-family: sans-serif;
      text-align: center;
      padding: 2rem;
    }
    canvas {
      display: block;
      margin: auto;
      background: transparent;
    }
    input {
      margin: 0.5rem;
    }
    button {
      margin-top: 1rem;
      padding: 0.5rem 1rem;
      font-size: 1rem;
      background: #3392ff;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <h1>3面テクスチャ → 3Dブロック画像</h1>
  <input type="file" id="front" accept="image/*"> 前面<br>
  <input type="file" id="side" accept="image/*"> 側面<br>
  <input type="file" id="top" accept="image/*"> 上面<br>
  <button id="generate">生成＆保存</button>

  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';

    const frontInput = document.getElementById("front");
    const sideInput = document.getElementById("side");
    const topInput = document.getElementById("top");
    const button = document.getElementById("generate");

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 100);
    const renderer = new THREE.WebGLRenderer({ alpha: true, preserveDrawingBuffer: true, antialias: false });
    renderer.setSize(512, 512);
    document.body.appendChild(renderer.domElement);

    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(3, 5, 4);
    scene.add(dirLight);

    camera.position.set(2, 2, 2);
    camera.lookAt(0, 0, 0);

    function fileToTexture(file) {
      return new Promise((resolve) => {
        const reader = new FileReader();
        reader.onload = () => {
          const img = new Image();
          img.onload = () => {
            const texture = new THREE.Texture(img);
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.NearestFilter;
            texture.needsUpdate = true;
            resolve(texture);
          };
          img.src = reader.result;
        };
        reader.readAsDataURL(file);
      });
    }

    button.addEventListener("click", async () => {
      const front = frontInput.files[0];
      const side = sideInput.files[0];
      const top = topInput.files[0];
      if (!front || !side || !top) {
        alert("3面すべての画像を選択してください！");
        return;
      }

      const [frontTex, sideTex, topTex] = await Promise.all([
        fileToTexture(front),
        fileToTexture(side),
        fileToTexture(top),
      ]);

      const materials = [
        new THREE.MeshBasicMaterial({ map: sideTex }),  // right
        new THREE.MeshBasicMaterial({ map: sideTex }),  // left
        new THREE.MeshBasicMaterial({ map: topTex }),   // top
        new THREE.MeshBasicMaterial({ map: frontTex }), // bottom（代用）
        new THREE.MeshBasicMaterial({ map: frontTex }), // front
        new THREE.MeshBasicMaterial({ map: sideTex }),  // back
      ];

      scene.clear();
      scene.add(dirLight);
      scene.add(new THREE.AmbientLight(0xffffff, 0.6));

      const box = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), materials);
      scene.add(box);
      // エッジラインを追加
      const edges = new THREE.EdgesGeometry(box.geometry);
      const line = new THREE.LineSegments(
        edges,
        new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 1 })
      );
      box.add(line);


      camera.position.set(2, 2, 2);
      camera.lookAt(0, 0, 0);
      camera.updateProjectionMatrix();

      renderer.render(scene, camera);

      const dataURL = renderer.domElement.toDataURL("image/png");
      const a = document.createElement("a");
      a.href = dataURL;
      a.download = "block3d.png";
      a.click();
    });
  </script>
</body>
</html>
